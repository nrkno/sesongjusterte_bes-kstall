#+STARTUP: fold
#+STARTUP: indent
#+TITLE: Sesongjustering av besøkstall
#+EXPORT_FILE_NAME: readme.org
#+PROPERTY: header-args:python :session *Python* :tangle kode.py :comments both :eval never-export :exports both :results silent
#+PROPERTY: header-args:bash :results silent
* Oppsett av Pythonmiljø
Jeg bruker et Docker-bilde.
#+begin_src dockerfile :tangle .devcontainer/Dockerfile
FROM python:3.10-bookworm

WORKDIR /kode

ENV PYTHONPAKKER="\
numpy \
matplotlib \
scipy \
statsmodels \
pandas \
pandas_gbq \
pyright \
# pandas_gbq vil ha denne \
tqdm \
scikit-learn \
"

RUN python -m ensurepip --upgrade \
    && python -m pip install --upgrade --no-cache-dir $PYTHONPAKKER
#+end_src

Dette er devcontainer.json-filen som konfigurerer byggingen av bildet og kjøringen av beholderen. Jeg setter merkelappen python_dv (python datavitenskap) på bildet, og gir det navnet sesongjustering når beholderen fyres opp.
#+begin_src js :tangle .devcontainer/devcontainer.json
  {
      "name": "Python datavitenskap",
      "build": {"dockerfile": "Dockerfile",
    	      "options": ["-t", "python_dv"]},
      "mounts": [{"source": "/tmp", "target": "/tmp", "type": "bind"},
  	       {"source": "/home/n645982/.config/gcloud", "target": "/root/.config/gcloud", "type": "bind"}],
      "runArgs": ["-it", "--rm", "--name=sesongjustering"]
  }
#+end_src
* Konfigurering av Python shell i Emacs
Dette skriptet gjør at jeg kan kjøre Python REPL-en i beholderen.
#+begin_src bash :tangle docker-python-shell.sh
  #!/bin/bash
  devcontainer exec --workspace-folder . python
#+end_src

#+begin_src bash
  chmod u+x docker-python-shell.sh
#+end_src

#+begin_src emacs-lisp
  (setq python-shell-interpreter "~/Dokumenter/NRK TV/Sesjongjustering/docker-python-shell.sh"
        python-shell-interpreter-args "-i --simple-prompt"
        python-shell-completion-native-enable nil)
#+end_src
* Oppstart av devcontainer
Nå starter jeg opp beholderen.
#+begin_src bash
  devcontainer up --workspace-folder .
#+end_src
* Innledende undersøkelse
** Pythonbiblioteker
#+begin_src python :results silent
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import pandas as pd
  import pandas_gbq
  import statsmodels.api as sm
  from numpy import sqrt, pi, log, linspace, sin, column_stack, ones
  from scipy.optimize import curve_fit
  from cycler import cycler

  plt.rcParams['figure.constrained_layout.use'] = True
  #+end_src
** Spørringer
#+name: spørring
#+begin_src bigquery
  SELECT partitionDate dato, HLL_COUNT.MERGE(visitorsSketch) klienter
    FROM `nrk-datahub.snowplow_aggregate.service_daily_v01`
   WHERE nrkService = 'nrktv'
     AND partitionDate < CURRENT_DATE
   GROUP BY 1
   ORDER BY 1
#+end_src

#+name: progbesøk
#+begin_src bigquery
  WITH
    d AS (
      SELECT partitionDate dato, seriesTitleOrTitle, 
             HLL_COUNT.MERGE(visitorsSketch) `besøkende`,
        FROM `nrk-datahub.snowplow_aggregate.playback_daily_v02`
             JOIN `nrk-datahub.metadata_views.metadata_programs` USING(contentKey)
        WHERE partitionDate < CURRENT_DATE
          AND nrkService = 'nrktv'
        GROUP BY ALL),

    dd AS (
      SELECT partitionDate dato,  
             HLL_COUNT.MERGE(visitorsSketch) `tot besøkende`
        FROM `nrk-datahub.snowplow_aggregate.playback_daily_v02`
        WHERE partitionDate < CURRENT_DATE
          AND nrkService = 'nrktv'
        GROUP BY ALL),

    r AS (
      SELECT *, ROW_NUMBER() OVER(PARTITION BY dato ORDER BY `besøkende` DESC) rang
        FROM d
             JOIN dd USING(dato))
    
    SELECT *, ROUND(`besøkende` / `tot besøkende`, 5) andel
      FROM r
     WHERE rang < 2
     ORDER BY 1, rang
#+end_src
** Innlesning av data
#+begin_src python :noweb yes
  spørring = """
  <<spørring>>
  """
  df_org = pandas_gbq.read_gbq(spørring, dialect="standard", project_id="nrk-datahub")
  df_org["dato"]=pd.to_datetime(df_org.dato)
  df = df_org.copy()
#+end_src
** Hjelpefunksjoner
*** Sinuskurve
#+begin_src python
  def sinusbølge(t, A, phi, f=1, B=0):
      """Sinusbølge ved tidspunkt t for amplitude A, frekvens f og fase phi forskjøvet en høyde B."""
      return A*sin(2*pi*t*f + phi) + B
#+end_src

*** Parameterverdier i forklaring
#+begin_src python
  def print_pars(A, phi, f=1, B=0):
      if isinstance(A, str):
          return f"A={A}, f={f}, phi={phi}, B={B}"
      elif isinstance(A, float):
          return f"A={round(A, 2)}, f={round(f,2)}, phi={round(phi,2)}, B={round(B,2)}"
#+end_src

*** Fargelegging av datointervaller
#+begin_src python
  def fargelegg(ax, verdier):
      for xmin, xmax, col in verdier.values():
          ax.axvspan(xmin, xmax, color=col, alpha=.15)
#+end_src
** Plotting av data
#+begin_src python :results graphics file output :file tidsserie.png
  jul="purple"
  påske="orange"
  sommer="green"
  vm="steelblue"
  spesielle_datoer = dict(
      sommer23=["2023-07-01","2023-08-11", sommer],
      jul23=["2023-12-01", "2023-12-25", jul],
      påske24=["2024-03-22","2024-04-01", påske],
      sommer24=["2024-07-01","2024-08-11", sommer],
      jul24=["2024-12-01","2024-12-25", jul],
      vm=["2025-02-22","2025-03-13", vm],
      påske25=["2025-04-11","2025-04-21", påske])

  fig,ax=plt.subplots()
  ax.plot(df.dato, df.klienter)
  fargelegg(ax, spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie.png]]

Her ser jeg på tallene fra og med 1. juli 2023.
#+begin_src python :results graphics file output :file tidsserie_juli.png
  fig,ax=plt.subplots()
  ax.plot(df[df.dato >= "2023-07-01"].dato, df[df.dato >= "2023-07-01"].klienter)
  fargelegg(ax, spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie_juli.png]]

Figuren viser at tidsserien har ukentlige og årlige sesongvariasjoner. I tillegg kan det se ut til at den ukentlige sesonvariasjonen øker når antall besøkende øker. Dette er et tegn på at tidsserien er heteroskedastisk, og dermed ikke stasjonær. For å bøte på dette kan vi prøve å gjøre en logaritmisk transformasjon.
** Logaritmisk
#+begin_src  python :results graphics file output :file tidsserie_log.png
  fig,ax=plt.subplots()
  ax.plot(df[df.dato >= "2023-07-01"].dato, log(df[df.dato >= "2023-07-01"].klienter))
  fargelegg(ax, spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie_log.png]]

Tallverdien er nå mindre og vi kan gå videre med å prøve å lage en tidsseriemodell.
** Fjerne trend
Denne kurven ser ut som en del av en sinuskurve med en trend som går oppover. Først fjerner jeg trenden ved å estimere den med en lineær regresjon.
#+begin_src python :results replace graphics file output :file tidsserietrend.png
  df = df_org[df_org.dato >= "2023-07-01"]
  df.loc[:,"log_klienter"] = log(df.klienter)
  y = df.log_klienter
  x = linspace(1, len(df.klienter), len(df.klienter))
  X = sm.add_constant(x)
  res = sm.OLS(y,X).fit()

  fig,ax=plt.subplots()
  ax.plot(df.dato, df.log_klienter, label="observasjoner")
  ax.plot(df.dato, res.fittedvalues, label="trend")
  ax.legend()
#+end_src

#+RESULTS:
[[file:tidsserietrend.png]]

Nå prøver jeg å subtrahere verdien av trenden fra observasjonene.
#+begin_src python :results replace graphics file output :file tidsserie_uten_trend.png
  df.loc[:,"log_klienter_detrended"] = df.log_klienter - res.fittedvalues
  
  fig,ax=plt.subplots()
  ax.plot(df.dato, df.log_klienter_detrended, label="Uten trend")
  ax.legend()
  fargelegg(ax, spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie_uten_trend.png]]


** Tilpassing av sinusbølge til data
Nå prøver jeg å tilpasse dette til en sinusbølge. En sinusbølge er gitt ved det matematiske uttrykket
#+begin_export latex
A\sin(2\pi ft + \phi).
#+end_export

Her prøver jeg først en manuell tilnærming.

#+begin_src python :results replace graphics file output :file tidsserie_sin.png
  t = linspace(1,len(df.dato),len(df.dato))/365
  fig,ax=plt.subplots()
  ax.plot(df.dato, df.log_klienter_detrended)
  ax.plot(df.dato, sinusbølge(t, .3, -pi/9*4, .96), label=print_pars("0,3", "-pi/9*4", "0,96"))
  ax.legend()
#+end_src

#+RESULTS:
[[file:tidsserie_sin.png]]

Nå skal jeg lage en tilpasning som er maskinell basert på minste kvadrater.
#+begin_src python :results replace graphics file output :file tidsserie_fit.png
  startverdier1=[.25,-pi/9*4, .96, 0]
  # startverdier2=[.3,-3*pi/5,13.3,1]
  b1=([.15,-pi/2,.9, -.1],[.35,-pi/5*2,1.1,.1])
  log_verdier=df.log_klienter_detrended.values
  popt11, pcov11 = curve_fit(sinusbølge, t, log_verdier,
                             startverdier1, bounds=b1)
  fig,ax=plt.subplots()
  ax.plot(df.dato, log_verdier)
  ax.plot(df.dato, sinusbølge(t, *popt11), label=print_pars(*popt11))
  ax.legend()
#+end_src

#+RESULTS:
[[file:tidsserie_fit.png]]

Her prøver jeg å trekke tilpasningen fra dataene og se hva jeg sitter igjen med.
#+begin_src python :results replace graphics file output :file tidsserie_fit_diff.png
  fig,ax=plt.subplots()
  ax.plot(df.dato, log_verdier - sinusbølge(t, *popt11))
  fargelegg(ax, spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie_fit_diff.png]]


** Ukesdifferanse
En vanlig teknikk i tidsseriemodellering er å subtrahere verdien som kommer et gitt antall stidssteg før fra den gjeldende verdien. For eksempel er det naturlig å tenke seg at i en ukessyklus vil dagens verdi være likere verdien for samme dag forrige uke enn gårsdagens verdi.

Jeg starter først med å se på ukesdifferansene på log-tidsserien og sammenligner den med resultatet fra over.
#+begin_src python :results replace graphics file output :file tidsserie_diff.png
  fig,ax=plt.subplots(nrows=2, layout='constrained')
  ax[0].plot(df.dato, log_verdier - log_verdier.shift(7))
  ax[1].plot(df.dato, log_verdier - sinusbølge(t, *popt11))
  ax[0].set_title("ukesdiff")
  ax[1].set_title("sesongjustert")
  fargelegg(ax[0], spesielle_datoer)
  fargelegg(ax[1], spesielle_datoer)
#+end_src

#+RESULTS:
[[file:tidsserie_diff.png]]
Spesielt rundt jul og 17. mai er det store utslag.

** Kovariater
En annen teknikk er å legge til kovariater som man tenker kan påvirke besøkstallet. En slik kovariat kan være hverdag/helg. En annen kan være dager det er spesielle hendelser eller programmer som trekker flere besøkende. Vi har allerede sett tydelig at jul, påske, ski-VM og Maskorama er eksempler på hendelser og programmer som har en sånn effekt.

Hvordan kan vi identifisere programmer eller hendelser som trekker besøkende? Dager der det sendes programmer som gir mange besøk skiller seg gjerne ut i tidsserien. Avstanden mellom lave og høye verdier for antall besøkende i løpet av én uke blir stor disse stedene. La oss ta en glidende maks-, min- og snittverdi med et vindu på én uke for å se hva det viser. Vi ser også på forskjellen mellom maks og min.

#+begin_src python
  fig,axs=plt.subplots(nrows=2)
  ax=axs[0]
  ax.plot(df.dato, df.klienter.rolling(window=7).min(), label="min")
  ax.plot(df.dato, df.klienter.rolling(window=7).mean(), label="snitt")
  ax.plot(df.dato, df.klienter.rolling(window=7).max(), label="maks")
  ax.legend()
  ax=axs[1]
  ax.plot(df.dato, df.klienter.rolling(window=7).max() - df.klienter.rolling(window=7).min(), label="diff")
  ax.legend()
  plt.show()
#+end_src

La oss videre se på hvilke programmer som har fått flest besøkende hver dag i perioden vi så på over. Jeg markerer dagene hvor Dagsrevyen har vært dette programmet.
#+begin_src python :noweb yes
  spørring = """
  <<progbesøk>>
  """

  pb_org = pandas_gbq.read_gbq(spørring, dialect="standard", project_id="nrk-datahub")
  pb_org["dato"] = pd.to_datetime(pb_org.dato)
  pb_org["seriesTitleOrTitle"] = pb_org.seriesTitleOrTitle.astype("string")
  pb = pb_org.copy()
#+end_src

#+begin_src python
  with mpl.rc_context({"axes.prop_cycle" : cycler(color=plt.get_cmap("tab20").colors)}):
    fig,axs=plt.subplots(nrows=2)
    axs[0].plot(pb.dato, pb.besøkende, label="besøkende")
    axs[1].plot(pb.dato, pb.andel, label="andel av tot besøkende")
    for p, m in zip(pb.seriesTitleOrTitle.value_counts().index, 20*["o"]+20*["s"]+11*["x"]):
        axs[0].plot(pb.loc[pb.seriesTitleOrTitle == p].dato, pb.loc[pb.seriesTitleOrTitle == p].besøkende, m, label=p)
        axs[1].plot(pb.loc[pb.seriesTitleOrTitle == p].dato, pb.loc[pb.seriesTitleOrTitle == p].andel, m)

    fig.legend(loc="outside center left")
    plt.show()
#+end_src

#+begin_src python
  df["klienter_glid_min"] = df.klienter.rolling(window=7).min()
  df["klienter_glid_snitt"] = df.klienter.rolling(window=7).mean()
  df["klienter_glid_maks"] = df.klienter.rolling(window=7).max()
#+end_src

#+begin_src python  
  with mpl.rc_context({"axes.prop_cycle" : cycler(color=plt.get_cmap("tab20").colors)}):
    fig,axs=plt.subplots(nrows=4)
    ax=axs[0]
    ax.plot(df.dato, df.klienter_glid_min / df.klienter_glid_min.max(), label="min")
    ax.plot(df.dato, df.klienter_glid_snitt / df.klienter_glid_snitt.max(), label="snitt")
    ax.plot(df.dato, df.klienter_glid_maks / df.klienter_glid_maks.max(), label="maks")
    ax.legend()
    ax=axs[1]
    ax.plot(df.dato, df.klienter_glid_maks / df.klienter_glid_maks.max() - df.klienter_glid_min / df.klienter_glid_min.max(), label="diff")
    ax.legend()
    axs[2].plot(pb.dato, pb.besøkende / pb.besøkende.max(), label="besøkende")
    axs[3].plot(pb.dato, pb.andel / pb.andel.max(), label="andel av tot besøkende")
    for p, m in zip(pb.seriesTitleOrTitle.value_counts().index, 20*["o"]+20*["s"]+11*["x"]):
      axs[2].plot(pb.loc[pb.seriesTitleOrTitle == p].dato, pb.loc[pb.seriesTitleOrTitle == p].besøkende / pb.besøkende.max(), m, label=p)
      axs[3].plot(pb.loc[pb.seriesTitleOrTitle == p].dato, pb.loc[pb.seriesTitleOrTitle == p].andel / pb.andel.max(), m)

    fig.legend(loc="outside center left")
    plt.show()
#+end_src
** Stykkevis regresjon
Jeg har lyst til å prøve å lage stykkevis
** Konklusjon
De rå besøkstallene kan se ut som en del av en sinuskurve.
